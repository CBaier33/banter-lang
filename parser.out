Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    FALSE
    GOTO
    INSTRUCTION
    LP
    RP
    STRING
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> program statement
Rule 3     statement -> LET MNEUMONIC BE expression
Rule 4     statement -> IF comparison THEN statement
Rule 5     statement -> IF comparison THEN statement ELSE statement
Rule 6     statement -> RETURN expression
Rule 7     expression -> expression PLUS expression
Rule 8     expression -> expression MINUS expression
Rule 9     expression -> expression TIMES expression
Rule 10    expression -> expression DIVIDE expression
Rule 11    expression -> NUMBER
Rule 12    expression -> MNEUMONIC
Rule 13    expression -> comparison
Rule 14    comparison -> expression COMP_OP expression

Terminals, with rules where they appear

BE                   : 3
COMMA                : 
COMP_OP              : 14
DIVIDE               : 10
ELSE                 : 5
FALSE                : 
GOTO                 : 
IF                   : 4 5
INSTRUCTION          : 
LET                  : 3
LP                   : 
MINUS                : 8
MNEUMONIC            : 3 12
NUMBER               : 11
PLUS                 : 7
RETURN               : 6
RP                   : 
STRING               : 
THEN                 : 4 5
TIMES                : 9
TRUE                 : 
error                : 

Nonterminals, with rules where they appear

comparison           : 4 5 13
expression           : 3 6 7 7 8 8 9 9 10 10 14 14
program              : 2 0
statement            : 1 2 4 5 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . program statement
    (3) statement -> . LET MNEUMONIC BE expression
    (4) statement -> . IF comparison THEN statement
    (5) statement -> . IF comparison THEN statement ELSE statement
    (6) statement -> . RETURN expression

    LET             shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 5

    program                        shift and go to state 1
    statement                      shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . statement
    (3) statement -> . LET MNEUMONIC BE expression
    (4) statement -> . IF comparison THEN statement
    (5) statement -> . IF comparison THEN statement ELSE statement
    (6) statement -> . RETURN expression

    LET             shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 5

    statement                      shift and go to state 6

state 2

    (1) program -> statement .

    LET             reduce using rule 1 (program -> statement .)
    IF              reduce using rule 1 (program -> statement .)
    RETURN          reduce using rule 1 (program -> statement .)
    $end            reduce using rule 1 (program -> statement .)


state 3

    (3) statement -> LET . MNEUMONIC BE expression

    MNEUMONIC       shift and go to state 7


state 4

    (4) statement -> IF . comparison THEN statement
    (5) statement -> IF . comparison THEN statement ELSE statement
    (14) comparison -> . expression COMP_OP expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    comparison                     shift and go to state 8
    expression                     shift and go to state 9

state 5

    (6) statement -> RETURN . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 12
    comparison                     shift and go to state 13

state 6

    (2) program -> program statement .

    LET             reduce using rule 2 (program -> program statement .)
    IF              reduce using rule 2 (program -> program statement .)
    RETURN          reduce using rule 2 (program -> program statement .)
    $end            reduce using rule 2 (program -> program statement .)


state 7

    (3) statement -> LET MNEUMONIC . BE expression

    BE              shift and go to state 14


state 8

    (4) statement -> IF comparison . THEN statement
    (5) statement -> IF comparison . THEN statement ELSE statement
    (13) expression -> comparison .

    THEN            shift and go to state 15
    COMP_OP         reduce using rule 13 (expression -> comparison .)
    PLUS            reduce using rule 13 (expression -> comparison .)
    MINUS           reduce using rule 13 (expression -> comparison .)
    TIMES           reduce using rule 13 (expression -> comparison .)
    DIVIDE          reduce using rule 13 (expression -> comparison .)


state 9

    (14) comparison -> expression . COMP_OP expression
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression

    COMP_OP         shift and go to state 16
    PLUS            shift and go to state 17
    MINUS           shift and go to state 18
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20


state 10

    (11) expression -> NUMBER .

    COMP_OP         reduce using rule 11 (expression -> NUMBER .)
    PLUS            reduce using rule 11 (expression -> NUMBER .)
    MINUS           reduce using rule 11 (expression -> NUMBER .)
    TIMES           reduce using rule 11 (expression -> NUMBER .)
    DIVIDE          reduce using rule 11 (expression -> NUMBER .)
    LET             reduce using rule 11 (expression -> NUMBER .)
    IF              reduce using rule 11 (expression -> NUMBER .)
    RETURN          reduce using rule 11 (expression -> NUMBER .)
    $end            reduce using rule 11 (expression -> NUMBER .)
    ELSE            reduce using rule 11 (expression -> NUMBER .)
    THEN            reduce using rule 11 (expression -> NUMBER .)


state 11

    (12) expression -> MNEUMONIC .

    COMP_OP         reduce using rule 12 (expression -> MNEUMONIC .)
    PLUS            reduce using rule 12 (expression -> MNEUMONIC .)
    MINUS           reduce using rule 12 (expression -> MNEUMONIC .)
    TIMES           reduce using rule 12 (expression -> MNEUMONIC .)
    DIVIDE          reduce using rule 12 (expression -> MNEUMONIC .)
    LET             reduce using rule 12 (expression -> MNEUMONIC .)
    IF              reduce using rule 12 (expression -> MNEUMONIC .)
    RETURN          reduce using rule 12 (expression -> MNEUMONIC .)
    $end            reduce using rule 12 (expression -> MNEUMONIC .)
    ELSE            reduce using rule 12 (expression -> MNEUMONIC .)
    THEN            reduce using rule 12 (expression -> MNEUMONIC .)


state 12

    (6) statement -> RETURN expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    LET             reduce using rule 6 (statement -> RETURN expression .)
    IF              reduce using rule 6 (statement -> RETURN expression .)
    RETURN          reduce using rule 6 (statement -> RETURN expression .)
    $end            reduce using rule 6 (statement -> RETURN expression .)
    ELSE            reduce using rule 6 (statement -> RETURN expression .)
    PLUS            shift and go to state 17
    MINUS           shift and go to state 18
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    COMP_OP         shift and go to state 16


state 13

    (13) expression -> comparison .

    PLUS            reduce using rule 13 (expression -> comparison .)
    MINUS           reduce using rule 13 (expression -> comparison .)
    TIMES           reduce using rule 13 (expression -> comparison .)
    DIVIDE          reduce using rule 13 (expression -> comparison .)
    COMP_OP         reduce using rule 13 (expression -> comparison .)
    LET             reduce using rule 13 (expression -> comparison .)
    IF              reduce using rule 13 (expression -> comparison .)
    RETURN          reduce using rule 13 (expression -> comparison .)
    $end            reduce using rule 13 (expression -> comparison .)
    ELSE            reduce using rule 13 (expression -> comparison .)
    THEN            reduce using rule 13 (expression -> comparison .)


state 14

    (3) statement -> LET MNEUMONIC BE . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 21
    comparison                     shift and go to state 13

state 15

    (4) statement -> IF comparison THEN . statement
    (5) statement -> IF comparison THEN . statement ELSE statement
    (3) statement -> . LET MNEUMONIC BE expression
    (4) statement -> . IF comparison THEN statement
    (5) statement -> . IF comparison THEN statement ELSE statement
    (6) statement -> . RETURN expression

    LET             shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 5

    statement                      shift and go to state 22

state 16

    (14) comparison -> expression COMP_OP . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 23
    comparison                     shift and go to state 13

state 17

    (7) expression -> expression PLUS . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 24
    comparison                     shift and go to state 13

state 18

    (8) expression -> expression MINUS . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 25
    comparison                     shift and go to state 13

state 19

    (9) expression -> expression TIMES . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 26
    comparison                     shift and go to state 13

state 20

    (10) expression -> expression DIVIDE . expression
    (7) expression -> . expression PLUS expression
    (8) expression -> . expression MINUS expression
    (9) expression -> . expression TIMES expression
    (10) expression -> . expression DIVIDE expression
    (11) expression -> . NUMBER
    (12) expression -> . MNEUMONIC
    (13) expression -> . comparison
    (14) comparison -> . expression COMP_OP expression

    NUMBER          shift and go to state 10
    MNEUMONIC       shift and go to state 11

    expression                     shift and go to state 27
    comparison                     shift and go to state 13

state 21

    (3) statement -> LET MNEUMONIC BE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    LET             reduce using rule 3 (statement -> LET MNEUMONIC BE expression .)
    IF              reduce using rule 3 (statement -> LET MNEUMONIC BE expression .)
    RETURN          reduce using rule 3 (statement -> LET MNEUMONIC BE expression .)
    $end            reduce using rule 3 (statement -> LET MNEUMONIC BE expression .)
    ELSE            reduce using rule 3 (statement -> LET MNEUMONIC BE expression .)
    PLUS            shift and go to state 17
    MINUS           shift and go to state 18
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    COMP_OP         shift and go to state 16


state 22

    (4) statement -> IF comparison THEN statement .
    (5) statement -> IF comparison THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 4 (statement -> IF comparison THEN statement .)
    IF              reduce using rule 4 (statement -> IF comparison THEN statement .)
    RETURN          reduce using rule 4 (statement -> IF comparison THEN statement .)
    $end            reduce using rule 4 (statement -> IF comparison THEN statement .)
    ELSE            shift and go to state 28

  ! ELSE            [ reduce using rule 4 (statement -> IF comparison THEN statement .) ]


state 23

    (14) comparison -> expression COMP_OP expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    THEN            reduce using rule 14 (comparison -> expression COMP_OP expression .)
    COMP_OP         reduce using rule 14 (comparison -> expression COMP_OP expression .)
    PLUS            reduce using rule 14 (comparison -> expression COMP_OP expression .)
    MINUS           reduce using rule 14 (comparison -> expression COMP_OP expression .)
    TIMES           reduce using rule 14 (comparison -> expression COMP_OP expression .)
    DIVIDE          reduce using rule 14 (comparison -> expression COMP_OP expression .)
    LET             reduce using rule 14 (comparison -> expression COMP_OP expression .)
    IF              reduce using rule 14 (comparison -> expression COMP_OP expression .)
    RETURN          reduce using rule 14 (comparison -> expression COMP_OP expression .)
    $end            reduce using rule 14 (comparison -> expression COMP_OP expression .)
    ELSE            reduce using rule 14 (comparison -> expression COMP_OP expression .)

  ! PLUS            [ shift and go to state 17 ]
  ! MINUS           [ shift and go to state 18 ]
  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]
  ! COMP_OP         [ shift and go to state 16 ]


state 24

    (7) expression -> expression PLUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    PLUS            reduce using rule 7 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 7 (expression -> expression PLUS expression .)
    LET             reduce using rule 7 (expression -> expression PLUS expression .)
    IF              reduce using rule 7 (expression -> expression PLUS expression .)
    RETURN          reduce using rule 7 (expression -> expression PLUS expression .)
    $end            reduce using rule 7 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 7 (expression -> expression PLUS expression .)
    THEN            reduce using rule 7 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    COMP_OP         shift and go to state 16

  ! COMP_OP         [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 7 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 17 ]
  ! MINUS           [ shift and go to state 18 ]


state 25

    (8) expression -> expression MINUS expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    PLUS            reduce using rule 8 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 8 (expression -> expression MINUS expression .)
    LET             reduce using rule 8 (expression -> expression MINUS expression .)
    IF              reduce using rule 8 (expression -> expression MINUS expression .)
    RETURN          reduce using rule 8 (expression -> expression MINUS expression .)
    $end            reduce using rule 8 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 8 (expression -> expression MINUS expression .)
    THEN            reduce using rule 8 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 19
    DIVIDE          shift and go to state 20
    COMP_OP         shift and go to state 16

  ! COMP_OP         [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 8 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 17 ]
  ! MINUS           [ shift and go to state 18 ]


state 26

    (9) expression -> expression TIMES expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    PLUS            reduce using rule 9 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 9 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 9 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 9 (expression -> expression TIMES expression .)
    LET             reduce using rule 9 (expression -> expression TIMES expression .)
    IF              reduce using rule 9 (expression -> expression TIMES expression .)
    RETURN          reduce using rule 9 (expression -> expression TIMES expression .)
    $end            reduce using rule 9 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 9 (expression -> expression TIMES expression .)
    THEN            reduce using rule 9 (expression -> expression TIMES expression .)
    COMP_OP         shift and go to state 16

  ! COMP_OP         [ reduce using rule 9 (expression -> expression TIMES expression .) ]
  ! PLUS            [ shift and go to state 17 ]
  ! MINUS           [ shift and go to state 18 ]
  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]


state 27

    (10) expression -> expression DIVIDE expression .
    (7) expression -> expression . PLUS expression
    (8) expression -> expression . MINUS expression
    (9) expression -> expression . TIMES expression
    (10) expression -> expression . DIVIDE expression
    (14) comparison -> expression . COMP_OP expression

    PLUS            reduce using rule 10 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 10 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 10 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 10 (expression -> expression DIVIDE expression .)
    LET             reduce using rule 10 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 10 (expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 10 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 10 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 10 (expression -> expression DIVIDE expression .)
    THEN            reduce using rule 10 (expression -> expression DIVIDE expression .)
    COMP_OP         shift and go to state 16

  ! COMP_OP         [ reduce using rule 10 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 17 ]
  ! MINUS           [ shift and go to state 18 ]
  ! TIMES           [ shift and go to state 19 ]
  ! DIVIDE          [ shift and go to state 20 ]


state 28

    (5) statement -> IF comparison THEN statement ELSE . statement
    (3) statement -> . LET MNEUMONIC BE expression
    (4) statement -> . IF comparison THEN statement
    (5) statement -> . IF comparison THEN statement ELSE statement
    (6) statement -> . RETURN expression

    LET             shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 5

    statement                      shift and go to state 29

state 29

    (5) statement -> IF comparison THEN statement ELSE statement .

    LET             reduce using rule 5 (statement -> IF comparison THEN statement ELSE statement .)
    IF              reduce using rule 5 (statement -> IF comparison THEN statement ELSE statement .)
    RETURN          reduce using rule 5 (statement -> IF comparison THEN statement ELSE statement .)
    $end            reduce using rule 5 (statement -> IF comparison THEN statement ELSE statement .)
    ELSE            reduce using rule 5 (statement -> IF comparison THEN statement ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 22 resolved as shift
