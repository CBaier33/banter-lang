Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FALSE
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> statement program
Rule 3     statement -> let_statement
Rule 4     statement -> if_statement
Rule 5     statement -> if_else_statement
Rule 6     statement -> return_statement
Rule 7     statement -> goto_statement
Rule 8     let_statement -> LET MNEUMONIC BE arithmetic_expression
Rule 9     if_statement -> IF comparison COMMA THEN block
Rule 10    if_else_statement -> IF comparison COMMA THEN block ELSE block
Rule 11    return_statement -> RETURN MNEUMONIC
Rule 12    return_statement -> RETURN NUMBER
Rule 13    return_statement -> RETURN STRING
Rule 14    goto_statement -> GOTO INSTRUCTION NUMBER
Rule 15    block -> statement
Rule 16    block -> statement block
Rule 17    arithmetic_expression -> term
Rule 18    arithmetic_expression -> arithmetic_expression PLUS term
Rule 19    arithmetic_expression -> arithmetic_expression MINUS term
Rule 20    term -> factor
Rule 21    term -> term TIMES factor
Rule 22    term -> term DIVIDE factor
Rule 23    factor -> MNEUMONIC
Rule 24    factor -> NUMBER
Rule 25    factor -> LP arithmetic_expression RP
Rule 26    comparison -> arithmetic_expression COMP_OP arithmetic_expression

Terminals, with rules where they appear

BE                   : 8
COMMA                : 9 10
COMP_OP              : 26
DIVIDE               : 22
ELSE                 : 10
FALSE                : 
GOTO                 : 14
IF                   : 9 10
INSTRUCTION          : 14
LET                  : 8
LP                   : 25
MINUS                : 19
MNEUMONIC            : 8 11 23
NUMBER               : 12 14 24
PLUS                 : 18
RETURN               : 11 12 13
RP                   : 25
STRING               : 13
THEN                 : 9 10
TIMES                : 21
TRUE                 : 
error                : 

Nonterminals, with rules where they appear

arithmetic_expression : 8 18 19 25 26 26
block                : 9 10 10 16
comparison           : 9 10
factor               : 20 21 22
goto_statement       : 7
if_else_statement    : 5
if_statement         : 4
let_statement        : 3
program              : 2 0
return_statement     : 6
statement            : 1 2 15 16
term                 : 17 18 19 21 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . let_statement
    (4) statement -> . if_statement
    (5) statement -> . if_else_statement
    (6) statement -> . return_statement
    (7) statement -> . goto_statement
    (8) let_statement -> . LET MNEUMONIC BE arithmetic_expression
    (9) if_statement -> . IF comparison COMMA THEN block
    (10) if_else_statement -> . IF comparison COMMA THEN block ELSE block
    (11) return_statement -> . RETURN MNEUMONIC
    (12) return_statement -> . RETURN NUMBER
    (13) return_statement -> . RETURN STRING
    (14) goto_statement -> . GOTO INSTRUCTION NUMBER

    LET             shift and go to state 8
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    GOTO            shift and go to state 11

    program                        shift and go to state 1
    statement                      shift and go to state 2
    let_statement                  shift and go to state 3
    if_statement                   shift and go to state 4
    if_else_statement              shift and go to state 5
    return_statement               shift and go to state 6
    goto_statement                 shift and go to state 7

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .
    (2) program -> statement . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . let_statement
    (4) statement -> . if_statement
    (5) statement -> . if_else_statement
    (6) statement -> . return_statement
    (7) statement -> . goto_statement
    (8) let_statement -> . LET MNEUMONIC BE arithmetic_expression
    (9) if_statement -> . IF comparison COMMA THEN block
    (10) if_else_statement -> . IF comparison COMMA THEN block ELSE block
    (11) return_statement -> . RETURN MNEUMONIC
    (12) return_statement -> . RETURN NUMBER
    (13) return_statement -> . RETURN STRING
    (14) goto_statement -> . GOTO INSTRUCTION NUMBER

    $end            reduce using rule 1 (program -> statement .)
    LET             shift and go to state 8
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    GOTO            shift and go to state 11

    statement                      shift and go to state 2
    program                        shift and go to state 12
    let_statement                  shift and go to state 3
    if_statement                   shift and go to state 4
    if_else_statement              shift and go to state 5
    return_statement               shift and go to state 6
    goto_statement                 shift and go to state 7

state 3

    (3) statement -> let_statement .

    LET             reduce using rule 3 (statement -> let_statement .)
    IF              reduce using rule 3 (statement -> let_statement .)
    RETURN          reduce using rule 3 (statement -> let_statement .)
    GOTO            reduce using rule 3 (statement -> let_statement .)
    $end            reduce using rule 3 (statement -> let_statement .)
    ELSE            reduce using rule 3 (statement -> let_statement .)


state 4

    (4) statement -> if_statement .

    LET             reduce using rule 4 (statement -> if_statement .)
    IF              reduce using rule 4 (statement -> if_statement .)
    RETURN          reduce using rule 4 (statement -> if_statement .)
    GOTO            reduce using rule 4 (statement -> if_statement .)
    $end            reduce using rule 4 (statement -> if_statement .)
    ELSE            reduce using rule 4 (statement -> if_statement .)


state 5

    (5) statement -> if_else_statement .

    LET             reduce using rule 5 (statement -> if_else_statement .)
    IF              reduce using rule 5 (statement -> if_else_statement .)
    RETURN          reduce using rule 5 (statement -> if_else_statement .)
    GOTO            reduce using rule 5 (statement -> if_else_statement .)
    $end            reduce using rule 5 (statement -> if_else_statement .)
    ELSE            reduce using rule 5 (statement -> if_else_statement .)


state 6

    (6) statement -> return_statement .

    LET             reduce using rule 6 (statement -> return_statement .)
    IF              reduce using rule 6 (statement -> return_statement .)
    RETURN          reduce using rule 6 (statement -> return_statement .)
    GOTO            reduce using rule 6 (statement -> return_statement .)
    $end            reduce using rule 6 (statement -> return_statement .)
    ELSE            reduce using rule 6 (statement -> return_statement .)


state 7

    (7) statement -> goto_statement .

    LET             reduce using rule 7 (statement -> goto_statement .)
    IF              reduce using rule 7 (statement -> goto_statement .)
    RETURN          reduce using rule 7 (statement -> goto_statement .)
    GOTO            reduce using rule 7 (statement -> goto_statement .)
    $end            reduce using rule 7 (statement -> goto_statement .)
    ELSE            reduce using rule 7 (statement -> goto_statement .)


state 8

    (8) let_statement -> LET . MNEUMONIC BE arithmetic_expression

    MNEUMONIC       shift and go to state 13


state 9

    (9) if_statement -> IF . comparison COMMA THEN block
    (10) if_else_statement -> IF . comparison COMMA THEN block ELSE block
    (26) comparison -> . arithmetic_expression COMP_OP arithmetic_expression
    (17) arithmetic_expression -> . term
    (18) arithmetic_expression -> . arithmetic_expression PLUS term
    (19) arithmetic_expression -> . arithmetic_expression MINUS term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    comparison                     shift and go to state 14
    arithmetic_expression          shift and go to state 15
    term                           shift and go to state 16
    factor                         shift and go to state 17

state 10

    (11) return_statement -> RETURN . MNEUMONIC
    (12) return_statement -> RETURN . NUMBER
    (13) return_statement -> RETURN . STRING

    MNEUMONIC       shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23


state 11

    (14) goto_statement -> GOTO . INSTRUCTION NUMBER

    INSTRUCTION     shift and go to state 24


state 12

    (2) program -> statement program .

    $end            reduce using rule 2 (program -> statement program .)


state 13

    (8) let_statement -> LET MNEUMONIC . BE arithmetic_expression

    BE              shift and go to state 25


state 14

    (9) if_statement -> IF comparison . COMMA THEN block
    (10) if_else_statement -> IF comparison . COMMA THEN block ELSE block

    COMMA           shift and go to state 26


state 15

    (26) comparison -> arithmetic_expression . COMP_OP arithmetic_expression
    (18) arithmetic_expression -> arithmetic_expression . PLUS term
    (19) arithmetic_expression -> arithmetic_expression . MINUS term

    COMP_OP         shift and go to state 27
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29


state 16

    (17) arithmetic_expression -> term .
    (21) term -> term . TIMES factor
    (22) term -> term . DIVIDE factor

    COMP_OP         reduce using rule 17 (arithmetic_expression -> term .)
    PLUS            reduce using rule 17 (arithmetic_expression -> term .)
    MINUS           reduce using rule 17 (arithmetic_expression -> term .)
    RP              reduce using rule 17 (arithmetic_expression -> term .)
    LET             reduce using rule 17 (arithmetic_expression -> term .)
    IF              reduce using rule 17 (arithmetic_expression -> term .)
    RETURN          reduce using rule 17 (arithmetic_expression -> term .)
    GOTO            reduce using rule 17 (arithmetic_expression -> term .)
    $end            reduce using rule 17 (arithmetic_expression -> term .)
    ELSE            reduce using rule 17 (arithmetic_expression -> term .)
    COMMA           reduce using rule 17 (arithmetic_expression -> term .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31


state 17

    (20) term -> factor .

    TIMES           reduce using rule 20 (term -> factor .)
    DIVIDE          reduce using rule 20 (term -> factor .)
    COMP_OP         reduce using rule 20 (term -> factor .)
    PLUS            reduce using rule 20 (term -> factor .)
    MINUS           reduce using rule 20 (term -> factor .)
    RP              reduce using rule 20 (term -> factor .)
    LET             reduce using rule 20 (term -> factor .)
    IF              reduce using rule 20 (term -> factor .)
    RETURN          reduce using rule 20 (term -> factor .)
    GOTO            reduce using rule 20 (term -> factor .)
    $end            reduce using rule 20 (term -> factor .)
    ELSE            reduce using rule 20 (term -> factor .)
    COMMA           reduce using rule 20 (term -> factor .)


state 18

    (23) factor -> MNEUMONIC .

    TIMES           reduce using rule 23 (factor -> MNEUMONIC .)
    DIVIDE          reduce using rule 23 (factor -> MNEUMONIC .)
    COMP_OP         reduce using rule 23 (factor -> MNEUMONIC .)
    PLUS            reduce using rule 23 (factor -> MNEUMONIC .)
    MINUS           reduce using rule 23 (factor -> MNEUMONIC .)
    RP              reduce using rule 23 (factor -> MNEUMONIC .)
    LET             reduce using rule 23 (factor -> MNEUMONIC .)
    IF              reduce using rule 23 (factor -> MNEUMONIC .)
    RETURN          reduce using rule 23 (factor -> MNEUMONIC .)
    GOTO            reduce using rule 23 (factor -> MNEUMONIC .)
    $end            reduce using rule 23 (factor -> MNEUMONIC .)
    ELSE            reduce using rule 23 (factor -> MNEUMONIC .)
    COMMA           reduce using rule 23 (factor -> MNEUMONIC .)


state 19

    (24) factor -> NUMBER .

    TIMES           reduce using rule 24 (factor -> NUMBER .)
    DIVIDE          reduce using rule 24 (factor -> NUMBER .)
    COMP_OP         reduce using rule 24 (factor -> NUMBER .)
    PLUS            reduce using rule 24 (factor -> NUMBER .)
    MINUS           reduce using rule 24 (factor -> NUMBER .)
    RP              reduce using rule 24 (factor -> NUMBER .)
    LET             reduce using rule 24 (factor -> NUMBER .)
    IF              reduce using rule 24 (factor -> NUMBER .)
    RETURN          reduce using rule 24 (factor -> NUMBER .)
    GOTO            reduce using rule 24 (factor -> NUMBER .)
    $end            reduce using rule 24 (factor -> NUMBER .)
    ELSE            reduce using rule 24 (factor -> NUMBER .)
    COMMA           reduce using rule 24 (factor -> NUMBER .)


state 20

    (25) factor -> LP . arithmetic_expression RP
    (17) arithmetic_expression -> . term
    (18) arithmetic_expression -> . arithmetic_expression PLUS term
    (19) arithmetic_expression -> . arithmetic_expression MINUS term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    arithmetic_expression          shift and go to state 32
    term                           shift and go to state 16
    factor                         shift and go to state 17

state 21

    (11) return_statement -> RETURN MNEUMONIC .

    LET             reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)
    IF              reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)
    RETURN          reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)
    GOTO            reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)
    $end            reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)
    ELSE            reduce using rule 11 (return_statement -> RETURN MNEUMONIC .)


state 22

    (12) return_statement -> RETURN NUMBER .

    LET             reduce using rule 12 (return_statement -> RETURN NUMBER .)
    IF              reduce using rule 12 (return_statement -> RETURN NUMBER .)
    RETURN          reduce using rule 12 (return_statement -> RETURN NUMBER .)
    GOTO            reduce using rule 12 (return_statement -> RETURN NUMBER .)
    $end            reduce using rule 12 (return_statement -> RETURN NUMBER .)
    ELSE            reduce using rule 12 (return_statement -> RETURN NUMBER .)


state 23

    (13) return_statement -> RETURN STRING .

    LET             reduce using rule 13 (return_statement -> RETURN STRING .)
    IF              reduce using rule 13 (return_statement -> RETURN STRING .)
    RETURN          reduce using rule 13 (return_statement -> RETURN STRING .)
    GOTO            reduce using rule 13 (return_statement -> RETURN STRING .)
    $end            reduce using rule 13 (return_statement -> RETURN STRING .)
    ELSE            reduce using rule 13 (return_statement -> RETURN STRING .)


state 24

    (14) goto_statement -> GOTO INSTRUCTION . NUMBER

    NUMBER          shift and go to state 33


state 25

    (8) let_statement -> LET MNEUMONIC BE . arithmetic_expression
    (17) arithmetic_expression -> . term
    (18) arithmetic_expression -> . arithmetic_expression PLUS term
    (19) arithmetic_expression -> . arithmetic_expression MINUS term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    arithmetic_expression          shift and go to state 34
    term                           shift and go to state 16
    factor                         shift and go to state 17

state 26

    (9) if_statement -> IF comparison COMMA . THEN block
    (10) if_else_statement -> IF comparison COMMA . THEN block ELSE block

    THEN            shift and go to state 35


state 27

    (26) comparison -> arithmetic_expression COMP_OP . arithmetic_expression
    (17) arithmetic_expression -> . term
    (18) arithmetic_expression -> . arithmetic_expression PLUS term
    (19) arithmetic_expression -> . arithmetic_expression MINUS term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    arithmetic_expression          shift and go to state 36
    term                           shift and go to state 16
    factor                         shift and go to state 17

state 28

    (18) arithmetic_expression -> arithmetic_expression PLUS . term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    term                           shift and go to state 37
    factor                         shift and go to state 17

state 29

    (19) arithmetic_expression -> arithmetic_expression MINUS . term
    (20) term -> . factor
    (21) term -> . term TIMES factor
    (22) term -> . term DIVIDE factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    term                           shift and go to state 38
    factor                         shift and go to state 17

state 30

    (21) term -> term TIMES . factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    factor                         shift and go to state 39

state 31

    (22) term -> term DIVIDE . factor
    (23) factor -> . MNEUMONIC
    (24) factor -> . NUMBER
    (25) factor -> . LP arithmetic_expression RP

    MNEUMONIC       shift and go to state 18
    NUMBER          shift and go to state 19
    LP              shift and go to state 20

    factor                         shift and go to state 40

state 32

    (25) factor -> LP arithmetic_expression . RP
    (18) arithmetic_expression -> arithmetic_expression . PLUS term
    (19) arithmetic_expression -> arithmetic_expression . MINUS term

    RP              shift and go to state 41
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29


state 33

    (14) goto_statement -> GOTO INSTRUCTION NUMBER .

    LET             reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)
    IF              reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)
    RETURN          reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)
    GOTO            reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)
    $end            reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)
    ELSE            reduce using rule 14 (goto_statement -> GOTO INSTRUCTION NUMBER .)


state 34

    (8) let_statement -> LET MNEUMONIC BE arithmetic_expression .
    (18) arithmetic_expression -> arithmetic_expression . PLUS term
    (19) arithmetic_expression -> arithmetic_expression . MINUS term

    LET             reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    IF              reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    RETURN          reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    GOTO            reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    $end            reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    ELSE            reduce using rule 8 (let_statement -> LET MNEUMONIC BE arithmetic_expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29


state 35

    (9) if_statement -> IF comparison COMMA THEN . block
    (10) if_else_statement -> IF comparison COMMA THEN . block ELSE block
    (15) block -> . statement
    (16) block -> . statement block
    (3) statement -> . let_statement
    (4) statement -> . if_statement
    (5) statement -> . if_else_statement
    (6) statement -> . return_statement
    (7) statement -> . goto_statement
    (8) let_statement -> . LET MNEUMONIC BE arithmetic_expression
    (9) if_statement -> . IF comparison COMMA THEN block
    (10) if_else_statement -> . IF comparison COMMA THEN block ELSE block
    (11) return_statement -> . RETURN MNEUMONIC
    (12) return_statement -> . RETURN NUMBER
    (13) return_statement -> . RETURN STRING
    (14) goto_statement -> . GOTO INSTRUCTION NUMBER

    LET             shift and go to state 8
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    GOTO            shift and go to state 11

    block                          shift and go to state 42
    statement                      shift and go to state 43
    let_statement                  shift and go to state 3
    if_statement                   shift and go to state 4
    if_else_statement              shift and go to state 5
    return_statement               shift and go to state 6
    goto_statement                 shift and go to state 7

state 36

    (26) comparison -> arithmetic_expression COMP_OP arithmetic_expression .
    (18) arithmetic_expression -> arithmetic_expression . PLUS term
    (19) arithmetic_expression -> arithmetic_expression . MINUS term

    COMMA           reduce using rule 26 (comparison -> arithmetic_expression COMP_OP arithmetic_expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 29


state 37

    (18) arithmetic_expression -> arithmetic_expression PLUS term .
    (21) term -> term . TIMES factor
    (22) term -> term . DIVIDE factor

    COMP_OP         reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    PLUS            reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    MINUS           reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RP              reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LET             reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    IF              reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RETURN          reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    GOTO            reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    $end            reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    ELSE            reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    COMMA           reduce using rule 18 (arithmetic_expression -> arithmetic_expression PLUS term .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31


state 38

    (19) arithmetic_expression -> arithmetic_expression MINUS term .
    (21) term -> term . TIMES factor
    (22) term -> term . DIVIDE factor

    COMP_OP         reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    PLUS            reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    MINUS           reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RP              reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LET             reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    IF              reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RETURN          reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    GOTO            reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    $end            reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    ELSE            reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    COMMA           reduce using rule 19 (arithmetic_expression -> arithmetic_expression MINUS term .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 31


state 39

    (21) term -> term TIMES factor .

    TIMES           reduce using rule 21 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 21 (term -> term TIMES factor .)
    COMP_OP         reduce using rule 21 (term -> term TIMES factor .)
    PLUS            reduce using rule 21 (term -> term TIMES factor .)
    MINUS           reduce using rule 21 (term -> term TIMES factor .)
    RP              reduce using rule 21 (term -> term TIMES factor .)
    LET             reduce using rule 21 (term -> term TIMES factor .)
    IF              reduce using rule 21 (term -> term TIMES factor .)
    RETURN          reduce using rule 21 (term -> term TIMES factor .)
    GOTO            reduce using rule 21 (term -> term TIMES factor .)
    $end            reduce using rule 21 (term -> term TIMES factor .)
    ELSE            reduce using rule 21 (term -> term TIMES factor .)
    COMMA           reduce using rule 21 (term -> term TIMES factor .)


state 40

    (22) term -> term DIVIDE factor .

    TIMES           reduce using rule 22 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 22 (term -> term DIVIDE factor .)
    COMP_OP         reduce using rule 22 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 22 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 22 (term -> term DIVIDE factor .)
    RP              reduce using rule 22 (term -> term DIVIDE factor .)
    LET             reduce using rule 22 (term -> term DIVIDE factor .)
    IF              reduce using rule 22 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 22 (term -> term DIVIDE factor .)
    GOTO            reduce using rule 22 (term -> term DIVIDE factor .)
    $end            reduce using rule 22 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 22 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 22 (term -> term DIVIDE factor .)


state 41

    (25) factor -> LP arithmetic_expression RP .

    TIMES           reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    DIVIDE          reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    COMP_OP         reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    PLUS            reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    MINUS           reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    RP              reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    LET             reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    IF              reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    RETURN          reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    GOTO            reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    $end            reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    ELSE            reduce using rule 25 (factor -> LP arithmetic_expression RP .)
    COMMA           reduce using rule 25 (factor -> LP arithmetic_expression RP .)


state 42

    (9) if_statement -> IF comparison COMMA THEN block .
    (10) if_else_statement -> IF comparison COMMA THEN block . ELSE block

  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .)
    IF              reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .)
    RETURN          reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .)
    GOTO            reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .)
    $end            reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .)
    ELSE            shift and go to state 44

  ! ELSE            [ reduce using rule 9 (if_statement -> IF comparison COMMA THEN block .) ]


state 43

    (15) block -> statement .
    (16) block -> statement . block
    (15) block -> . statement
    (16) block -> . statement block
    (3) statement -> . let_statement
    (4) statement -> . if_statement
    (5) statement -> . if_else_statement
    (6) statement -> . return_statement
    (7) statement -> . goto_statement
    (8) let_statement -> . LET MNEUMONIC BE arithmetic_expression
    (9) if_statement -> . IF comparison COMMA THEN block
    (10) if_else_statement -> . IF comparison COMMA THEN block ELSE block
    (11) return_statement -> . RETURN MNEUMONIC
    (12) return_statement -> . RETURN NUMBER
    (13) return_statement -> . RETURN STRING
    (14) goto_statement -> . GOTO INSTRUCTION NUMBER

  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for GOTO resolved as shift
    ELSE            reduce using rule 15 (block -> statement .)
    $end            reduce using rule 15 (block -> statement .)
    LET             shift and go to state 8
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    GOTO            shift and go to state 11

  ! LET             [ reduce using rule 15 (block -> statement .) ]
  ! IF              [ reduce using rule 15 (block -> statement .) ]
  ! RETURN          [ reduce using rule 15 (block -> statement .) ]
  ! GOTO            [ reduce using rule 15 (block -> statement .) ]

    statement                      shift and go to state 43
    block                          shift and go to state 45
    let_statement                  shift and go to state 3
    if_statement                   shift and go to state 4
    if_else_statement              shift and go to state 5
    return_statement               shift and go to state 6
    goto_statement                 shift and go to state 7

state 44

    (10) if_else_statement -> IF comparison COMMA THEN block ELSE . block
    (15) block -> . statement
    (16) block -> . statement block
    (3) statement -> . let_statement
    (4) statement -> . if_statement
    (5) statement -> . if_else_statement
    (6) statement -> . return_statement
    (7) statement -> . goto_statement
    (8) let_statement -> . LET MNEUMONIC BE arithmetic_expression
    (9) if_statement -> . IF comparison COMMA THEN block
    (10) if_else_statement -> . IF comparison COMMA THEN block ELSE block
    (11) return_statement -> . RETURN MNEUMONIC
    (12) return_statement -> . RETURN NUMBER
    (13) return_statement -> . RETURN STRING
    (14) goto_statement -> . GOTO INSTRUCTION NUMBER

    LET             shift and go to state 8
    IF              shift and go to state 9
    RETURN          shift and go to state 10
    GOTO            shift and go to state 11

    block                          shift and go to state 46
    statement                      shift and go to state 43
    let_statement                  shift and go to state 3
    if_statement                   shift and go to state 4
    if_else_statement              shift and go to state 5
    return_statement               shift and go to state 6
    goto_statement                 shift and go to state 7

state 45

    (16) block -> statement block .

    LET             reduce using rule 16 (block -> statement block .)
    IF              reduce using rule 16 (block -> statement block .)
    RETURN          reduce using rule 16 (block -> statement block .)
    GOTO            reduce using rule 16 (block -> statement block .)
    ELSE            reduce using rule 16 (block -> statement block .)
    $end            reduce using rule 16 (block -> statement block .)


state 46

    (10) if_else_statement -> IF comparison COMMA THEN block ELSE block .

    LET             reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)
    IF              reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)
    RETURN          reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)
    GOTO            reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)
    $end            reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)
    ELSE            reduce using rule 10 (if_else_statement -> IF comparison COMMA THEN block ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 42 resolved as shift
WARNING: shift/reduce conflict for LET in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 43 resolved as shift
WARNING: shift/reduce conflict for GOTO in state 43 resolved as shift
